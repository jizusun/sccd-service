var MySQL = require("mysql");

module.exports = DB;

function DB(options){
    this.sDbName = options.name;
    this._oConnection = null;
};

DB.prototype.connect = function(){
    this._oConnection = MySQL.createConnection({
        host: "localhost",
        user: "guest",
        password: "guest",
        database: this.sDbName,
        port: "3306"
    });
    this._oConnection.connect();
};

DB.prototype.close = function(){
    if(this._oConnection){
        this._oConnection.end();
        this._oConnection = null;
    }
};

DB.prototype.query = function(sSql, aParam, fnCallback){
    if(aParam && Array.isArray(aParam)){
        this._oConnection.query(sSql, aParam, fnCallback);
    }else{
        this._oConnection.query(sSql, fnCallback);
    }
};

DB.prototype.executeSql = function(sSql, aParam, vExtra){
    if(sSql){
        this.connect();
        if(typeof vExtra === "function"){
            this.query(sSql, aParam, vExtra);
        }else{
            this.query(sSql, aParam, function(oError, oResult){
                if(oError){
                    console.log("DB error:" + oError.message);
                    return;
                }
                console.log(vExtra);
            });
        }
        this.close();
    }
};

DB.prototype.selectDBItem = function(oParam){
    var aKey = Object.keys(oParam.keys);
    var sSql = "SELECT " + oParam.values.join(",") +
                    " FROM " + oParam.table +
                    " WHERE " + aKey.map(function(sKey){ return sKey + "=?"; }).join(" AND ") +
                                (oParam.specialCondition !== undefined ? (" AND " + oParam.specialCondition) : "");
    var aParam = aKey.map(function(sKey){
        return oParam.keys[sKey];
    });

    this.executeSql(sSql, aParam, oParam.fnCallback);
};

DB.prototype.insertDBItem = function(oParam){
    var aValKey = Object.keys(oParam.values);
    var sSql = "INSERT INTO " + oParam.table +
                    "(" + aValKey.join(",") + ")" +
                    "VALUES(" + aValKey.map(function(sKey){ return "?"; }).join(",") + ")";
    var aParam = aValKey.map(function(sKey){
        return oParam.values[sKey];
    });

    this.executeSql(sSql, aParam, "Insert " + oParam.table + " values: " + JSON.stringify(oParam.values) + " successfully.");
};

DB.prototype.updateDBItem = function(oParam){
    var aValKey = Object.keys(oParam.values);
    var aKey = Object.keys(oParam.keys);
    var sSql = "UPDATE " + oParam.table + 
                    " SET " + aValKey.map(function(sKey){ return sKey + "=?"; }).join(",") +
                    " WHERE " + aKey.map(function(sKey){ return sKey + "=?"; }).join(" AND ");
    var aParam = aValKey.map(function(sKey){
        return oParam.values[sKey];
    }).concat(aKey.map(function(sKey){
        return oParam.keys[sKey];
    }));

    this.executeSql(sSql, aParam, "Update " + oParam.table + " keys: " + JSON.stringify(oParam.keys) + ", values: " + JSON.stringify(oParam.values) + " successfully.");
};

/**
  Insert a new record when it does not exist in the DB. Or update it depends on the input 'bUpdate' flag
    bUpdate(boolean): Update the item or not when there is already
    oParam(object): {
        table(string): DB table name
        values(array): field names which act as returned fields of SQL SELECT statement
        keys(object): key-value pairs which appear in WHERE clause as select criteria. If value of key cannot be determined before SELECT,
                      such as auto_increment field, value must be provided as 'undefined' in the parameter
        specialCondition(string): special select criteria which cannot be provided as key-value mode, such as 'timestamp LIKE '20180601%''
        fnCallback(function): DB query callback function
    }
*/
DB.prototype.insertNewUpdateExistDBItem = function(bUpdate, oParam){
    this.selectDBItem({
        table: oParam.table,
        values: Object.keys(oParam.keys),
        keys: JSON.parse(JSON.stringify(oParam.keys)), //Remove object field whose value is undefined
        specialCondition: oParam.specialCondition,
        fnCallback: function(oError, aRow){
            if(oError){
                console.log("Check " + oParam.table + " (" + JSON.stringify(oParam.keys) + ") existence failed. Message: " + oError.message);
                return;
            }
            
            if(aRow.length === 0){
                //console.log("Create a new " + oParam.table + " " + JSON.stringify(Object.assign({}, oParam.keys, oParam.values)));

                this.insertDBItem({
                    table: oParam.table,
                    values: JSON.parse(JSON.stringify(Object.assign({}, oParam.keys, oParam.values))) //Remove object field whose value is undefined. These fields are auto_increment which are generated by DB when do INSERT
                });
            }else if(bUpdate){
                //console.log("Update an existing " + oParam.table + ", keys: " + JSON.stringify(oParam.keys) + ", values: " + JSON.stringify(oParam.values));

                this.updateDBItem({
                    table: oParam.table,
                    keys: Object.assign(oParam.keys, aRow[0]), //Backfill key fields' values since auto_increment field is given as undefined in the parameter
                    values: oParam.values
                });
            }else{
                console.log(oParam.table + " with keys: " + JSON.stringify(oParam.keys) + " exist yet.");
            }
        }.bind(this)
    });
};

DB.prototype.freeSqlPromise = function(sSql){
    return new Promise(function(resolve, reject){
        try{
            this.connect();
            this.query(sSql, function(oError, aResult){
                if(oError){
                    reject("[Database error] - " + oError.message);
                }

                resolve(aResult);
            });
            this.close();

        }catch(oError){
            reject(oError);
        }
    }.bind(this));
};

